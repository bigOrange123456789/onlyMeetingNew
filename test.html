<!DOCTYPE html>
<html lang="en">
	<head>
		<title>MEETING--softwareTest</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {overflow:hidden;}
		</style>
	</head>

	<body>
	<!--有骨骼动画的着色器-->
	<!--矩阵插值代码-->
	<!--
					    //求下一个矩阵
					        	            frame_index++;
        	            if(frame_index==36)frame_index=0;
						px=skeletonData[80*frame_index+10*iii+0];
						py=skeletonData[80*frame_index+10*iii+1];
						pz=skeletonData[80*frame_index+10*iii+2];
						x=skeletonData[80*frame_index+10*iii+3];
						y=skeletonData[80*frame_index+10*iii+4];
						z=skeletonData[80*frame_index+10*iii+5];
						w=skeletonData[80*frame_index+10*iii+6];


						x2 = x + x;	y2 = y + y; z2 = z + z;
    	                xx = x * x2;xy = x * y2;xz = x * z2;
        	            yy = y * y2;yz = y * z2;zz = z * z2;
            	        wx = w * x2;wy = w * y2;wz = w * z2;
                	    m2=mat4(
                    		( 1.0-( yy + zz ) ),( xy + wz )         ,( xz - wy )         ,0.0,
                    		( xy - wz )        ,( 1.0-( xx + zz ) ) ,( yz + wx )         ,0.0,
	                    	( xz + wy )        ,( yz - wx )         ,( 1.0-( xx + yy ) ) ,0.0,
    	                	px                 ,py                  ,pz                  ,1.0
        	            );

					//将两个矩阵结合
					//float b=t-floor(t);   if(b==0.0)b=1.0;
					//b=1.0-b;
					//float b=1.0-k;
					return m1;
                    /*return mat4(
                    	m1[0][0]+b*(m2[0][0]-m1[0][0]),	m1[0][1]+b*(m2[0][1]-m1[0][1]),	m1[0][2]+b*(m2[0][2]-m1[0][2]),	m1[0][3]+b*(m2[0][3]-m1[0][3]),
                    	m1[1][0]+b*(m2[1][0]-m1[1][0]),	m1[1][1]+b*(m2[1][1]-m1[1][1]),	m1[1][2]+b*(m2[1][2]-m1[1][2]),	m1[1][3]+b*(m2[1][3]-m1[1][3]),
                    	m1[2][0]+b*(m2[2][0]-m1[2][0]),	m1[2][1]+b*(m2[2][1]-m1[2][1]),	m1[2][2]+b*(m2[2][2]-m1[2][2]),	m1[2][3]+b*(m2[2][3]-m1[2][3]),
                    	m1[3][0]+b*(m2[3][0]-m1[3][0]),	m1[3][1]+b*(m2[3][1]-m1[3][1]),	m1[3][2]+b*(m2[3][2]-m1[3][2]),	m1[3][3]+b*(m2[3][3]-m1[3][3])
                    );*/
	-->
	<!--计算手臂部分的骨骼数据-->
	<!--
	//开始计算matrix
            /*var data=[];
            for(var time=0;time<8;time++){//0-7
                matrixs0=[];matrixs=[];
                for(i=0;i<25;i++){
                    matrixs0.push(
                        compose(
                            animation.tracks[3*i+1].values[4*time],
                            animation.tracks[3*i+1].values[4*time+1],
                            animation.tracks[3*i+1].values[4*time+2],
                            animation.tracks[3*i+1].values[4*time+3],

                            animation.tracks[3*i+2].values[3*time],
                            animation.tracks[3*i+2].values[3*time+1],
                            animation.tracks[3*i+2].values[3*time+2],

                            animation.tracks[3*i].values[3*time],
                            animation.tracks[3*i].values[3*time+1],
                            animation.tracks[3*i].values[3*time+2]
                        )
                        //scope.originMeshs[0].skeleton.bones[i].matrix.clone()
                    );
                    matrixs.push(
                        scope.originMeshs[0].skeleton.boneInverses[i].clone()
                    );
                }

                //矩阵3没有乘以逆矩阵
                var tool=matrixs0[0];
                matrixs[0]=tool.clone().multiply(matrixs[0]);tool=tool.clone().multiply(matrixs0[1]);
                matrixs[1]=tool.clone().multiply(matrixs[1]);tool=tool.clone().multiply(matrixs0[2]);
                matrixs[2]=tool.clone().multiply(matrixs[2]);tool=tool.clone().multiply(matrixs0[3]);  var  _tool3=tool;



                tool=_tool3;
                tool=tool.clone().multiply(matrixs0[7]);
                matrixs[7]=tool.clone().multiply(matrixs[7]);tool=tool.clone().multiply(matrixs0[8]);
                matrixs[8]=tool.clone().multiply(matrixs[8]);tool=tool.clone().multiply(matrixs0[9]);
                matrixs[9]=tool.clone().multiply(matrixs[9]);tool=tool.clone().multiply(matrixs0[10]);
                matrixs[10]=tool.clone().multiply(matrixs[10]);

                tool=_tool3;
                tool=tool.clone().multiply(matrixs0[11]);
                matrixs[11]=tool.clone().multiply(matrixs[11]);tool=tool.clone().multiply(matrixs0[12]);
                matrixs[12]=tool.clone().multiply(matrixs[12]);tool=tool.clone().multiply(matrixs0[13]);
                matrixs[13]=tool.clone().multiply(matrixs[13]);tool=tool.clone().multiply(matrixs0[14]);
                matrixs[14]=tool.clone().multiply(matrixs[14]);

                var temp=[];
                temp.push(matrixs[7].toArray());
                temp.push(matrixs[8].toArray());
                temp.push(matrixs[9].toArray());
                temp.push(matrixs[10].toArray());
                temp.push(matrixs[11].toArray());
                temp.push(matrixs[12].toArray());
                temp.push(matrixs[13].toArray());
                temp.push(matrixs[14].toArray());
                for(var i=0;i<8;i++){
                    data.push(temp[i][0]);
                    data.push(temp[i][1]);
                    data.push(temp[i][2]);
                    data.push(temp[i][4]);
                    data.push(temp[i][5]);
                    data.push(temp[i][6]);
                    data.push(temp[i][8]);
                    data.push(temp[i][9]);
                    data.push(temp[i][10]);
                    data.push(temp[i][12]);
                    data.push(temp[i][13]);
                    data.push(temp[i][14]);
                }
            }//iii
            let link = document.createElement('a');
            link.style.display = 'none';
            document.body.appendChild(link);
            link.href = URL.createObjectURL(new Blob([JSON.stringify({data:data})], { type: 'text/plain' }));
            link.download ="skeletonData.json";
            link.click();*/
	-->
	<!--计算手臂部分的骨骼矩阵/压缩成12个数-->
	<!--
	var data=[];
            for(var time=0;time<8;time++){//0-7
            //var time=0;
                matrixs0=[];matrixs=[];
                for(i=0;i<25;i++){
                    matrixs0.push(
                        compose(
                            animation.tracks[3*i+1].values[4*time],
                            animation.tracks[3*i+1].values[4*time+1],
                            animation.tracks[3*i+1].values[4*time+2],
                            animation.tracks[3*i+1].values[4*time+3],

                            animation.tracks[3*i+2].values[3*time],
                            animation.tracks[3*i+2].values[3*time+1],
                            animation.tracks[3*i+2].values[3*time+2],

                            animation.tracks[3*i].values[3*time],
                            animation.tracks[3*i].values[3*time+1],
                            animation.tracks[3*i].values[3*time+2]
                        )
                        //scope.originMeshs[0].skeleton.bones[i].matrix.clone()
                    );
                    matrixs.push(
                        scope.originMeshs[0].skeleton.boneInverses[i].clone()
                    );
                }

                /////矩阵3没有乘以逆矩阵
                var tool=matrixs0[0];
                matrixs[0]=tool.clone().multiply(matrixs[0]);tool=tool.clone().multiply(matrixs0[1]);
                matrixs[1]=tool.clone().multiply(matrixs[1]);tool=tool.clone().multiply(matrixs0[2]);
                matrixs[2]=tool.clone().multiply(matrixs[2]);tool=tool.clone().multiply(matrixs0[3]);  var  _tool3=tool;
                matrixs[3]=tool.clone().multiply(matrixs[3]);tool=tool.clone().multiply(matrixs0[4]);
                matrixs[4]=tool.clone().multiply(matrixs[4]);tool=tool.clone().multiply(matrixs0[5]);
                matrixs[5]=tool.clone().multiply(matrixs[5]);tool=tool.clone().multiply(matrixs0[6]);
                matrixs[6]=tool.clone().multiply(matrixs[6]);

                tool=_tool3;
                tool=tool.clone().multiply(matrixs0[7]);
                matrixs[7]=tool.clone().multiply(matrixs[7]);tool=tool.clone().multiply(matrixs0[8]);
                matrixs[8]=tool.clone().multiply(matrixs[8]);tool=tool.clone().multiply(matrixs0[9]);
                matrixs[9]=tool.clone().multiply(matrixs[9]);tool=tool.clone().multiply(matrixs0[10]);
                matrixs[10]=tool.clone().multiply(matrixs[10]);

                tool=_tool3;
                tool=tool.clone().multiply(matrixs0[11]);
                matrixs[11]=tool.clone().multiply(matrixs[11]);tool=tool.clone().multiply(matrixs0[12]);
                matrixs[12]=tool.clone().multiply(matrixs[12]);tool=tool.clone().multiply(matrixs0[13]);
                matrixs[13]=tool.clone().multiply(matrixs[13]);tool=tool.clone().multiply(matrixs0[14]);
                matrixs[14]=tool.clone().multiply(matrixs[14]);

                tool=matrixs0[0].clone().multiply(matrixs0[15]);
                matrixs[15]=tool.clone().multiply(matrixs[15]);tool=tool.clone().multiply(matrixs0[16]);
                matrixs[16]=tool.clone().multiply(matrixs[16]);tool=tool.clone().multiply(matrixs0[17]);
                matrixs[17]=tool.clone().multiply(matrixs[17]);tool=tool.clone().multiply(matrixs0[18]);
                matrixs[18]=tool.clone().multiply(matrixs[18]);tool=tool.clone().multiply(matrixs0[19]);
                matrixs[19]=tool.clone().multiply(matrixs[19]);

                tool=matrixs0[0].clone().multiply(matrixs0[20]);
                matrixs[20]=tool.clone().multiply(matrixs[20]);tool=tool.clone().multiply(matrixs0[21]);
                matrixs[21]=tool.clone().multiply(matrixs[21]);tool=tool.clone().multiply(matrixs0[22]);
                matrixs[22]=tool.clone().multiply(matrixs[22]);tool=tool.clone().multiply(matrixs0[23]);
                matrixs[23]=tool.clone().multiply(matrixs[23]);tool=tool.clone().multiply(matrixs0[24]);
                matrixs[24]=tool.clone().multiply(matrixs[24]);/**/
                //完成计算matrix

            /*for(i=0;i<25;i++){
                var arr=matrixs[i].toArray();
                for(j=0;j<16;j++){
                    data.push(arr[j]);
                }
            }*/

            for(i of [7,8,9,10,11,12,13,14]){
                var temp=matrixs[i].toArray();
                for(j=0;j<16;j++){
                    //data.push(arr[j]);
                }
                data.push(temp[0]);
                data.push(temp[1]);
                data.push(temp[2]);
                data.push(temp[4]);
                data.push(temp[5]);
                data.push(temp[6]);
                data.push(temp[8]);
                data.push(temp[9]);
                data.push(temp[10]);
                data.push(temp[12]);
                data.push(temp[13]);
                data.push(temp[14]);
            }/**/

                /*var temp=[];
                temp.push(matrixs[7].toArray());
                temp.push(matrixs[8].toArray());
                temp.push(matrixs[9].toArray());
                temp.push(matrixs[10].toArray());
                temp.push(matrixs[11].toArray());
                temp.push(matrixs[12].toArray());
                temp.push(matrixs[13].toArray());
                temp.push(matrixs[14].toArray());
                for(var i=0;i<8;i++){
                    data.push(temp[i][0]);
                    data.push(temp[i][1]);
                    data.push(temp[i][2]);
                    data.push(temp[i][4]);
                    data.push(temp[i][5]);
                    data.push(temp[i][6]);
                    data.push(temp[i][8]);
                    data.push(temp[i][9]);
                    data.push(temp[i][10]);
                    data.push(temp[i][12]);
                    data.push(temp[i][13]);
                    data.push(temp[i][14]);
                }*/
            }//iii
            let link = document.createElement('a');
            link.style.display = 'none';
            document.body.appendChild(link);
            link.href = URL.createObjectURL(new Blob([JSON.stringify({data:data})], { type: 'text/plain' }));
            link.download ="skeletonData.json";
            //console.log(data);
            //link.click();/**/
	-->
	<!--shader中计算骨骼矩阵-->
	<!--
	float x,y,z,w,px,py,pz;
					float x2,y2,z2 ,
					      xx,xy,xz,
					      yy,yz,zz,
					      wx,wy,wz;


						px=skeletonData[80*frame_index+10*iii+0];
						py=skeletonData[80*frame_index+10*iii+1];
						pz=skeletonData[80*frame_index+10*iii+2];
						x=skeletonData[80*frame_index+10*iii+3];
						y=skeletonData[80*frame_index+10*iii+4];
						z=skeletonData[80*frame_index+10*iii+5];
						w=skeletonData[80*frame_index+10*iii+6];

						x2 = x + x;	y2 = y + y; z2 = z + z;
    	                xx = x * x2;xy = x * y2;xz = x * z2;
        	            yy = y * y2;yz = y * z2;zz = z * z2;
            	        wx = w * x2;wy = w * y2;wz = w * z2;
                	    mat4 m=mat4(
                    		( 1.0-( yy + zz ) ),( xy + wz )         ,( xz - wy )         ,0.0,
                    		( xy - wz )        ,( 1.0-( xx + zz ) ) ,( yz + wx )         ,0.0,
	                    	( xz + wy )        ,( yz - wx )         ,( 1.0-( xx + yy ) ) ,0.0,
    	                	px                 ,py                  ,pz                  ,1.0
        	            );

					return m;
	-->
	<script id="vertexShader" type="x-shader/x-vertex">
		#define dataTextureHeight 512.0

		precision highp float;//highp

		uniform sampler2D dataTexture;

		uniform mat4 modelViewMatrix;
		uniform mat4 projectionMatrix;

		uniform float skeletonMatrix[204];//骨骼(25-8)*12=204//骨骼矩阵//用于求不动位置的骨骼
		uniform float skeletonData[768];//帧数8*骨骼8*12=768//用于求手臂骨骼//8个手臂骨骼的数据//uniform float[]最大长度4088//变化范围12(0-11)

		uniform float time;//0-10000

		attribute vec3 position;
		attribute vec2 inUV;
        attribute vec4 skinIndex;

        attribute float random;

		attribute float speed;

		attribute vec3 mcol0;
		attribute vec3 mcol1;
		attribute vec3 mcol2;
		attribute vec3 mcol3;

		attribute vec4 type;   //type[3]是0或1，用于表示动画
		attribute vec3 color;

        varying vec2 outUV;
        varying vec3 varyType;
        varying vec3 varyColor;
        varying float type_part;
        varying float myTest00;
        varying vec3 myTest01;

		int frame_index;

		float modFloor(float a,float b);
		int float2int(float n);
		float int2float(int n);
		float getNumByTexture(float n);
		float decode(float A,float B);//0-1
		float getI(int m);//取手臂骨骼数据
		void frame_indexSet();//求帧序号
        mat4 getMatrixs_i(int i);//求不动位置的骨骼
		mat4 getMatrixs0_i(int iii);//求手臂骨骼
		mat4 getMatrix(int i);//求骨骼
		float computeErr_i(int b);//0-1
		float computeErr(int type);
		int computeErr_();
		void noShader();

		void main(){
				vec3 tttt=texture2D(dataTexture, vec2(
						(0.5+0.0)/1.0,//宽width
						(0.5+floor(4.0/3.0))/dataTextureHeight //高height
				)).xyz;
				//tttt;
				float a=1.0;
				float aa=1.0;
				int bb=1;
				float err=
					(
						decode(getNumByTexture(aa+0.0),getNumByTexture(aa+768.0))
						-
						skeletonData[bb]
					)/(skeletonData[bb]*2.56);
					//440
				myTest01=vec3(
					getNumByTexture(0.0),//computeErr(0),
					computeErr_i(0),
					computeErr_i(446)
				);/**/
				//1,0 3=(1+0*5)*3
				/*if(getNumByTexture(0.0)!=0.0){
					gl_Position=vec4( 0.0,0.0,0.0,0.0 );
					return;
				}*/



			    vec3 vPosition = position;

				outUV = inUV;
				varyType=vec3(type[0],type[1],type[2]);
				varyColor=vec3(color[0],color[1],color[2]);
				noShader();
				/*if(vPosition.x<-0.12){
					gl_Position=vec4( 0.0,0.0,0.0,0.0 );
					return;
				}*/
				if(vPosition.y<0.15&&(vPosition.z<0.35&&vPosition.z>-0.35))type_part=0.0;//下身
				else if(vPosition.y<0.59) type_part=1.0;//上身
				else type_part=2.0;//头部

				frame_indexSet();//设置全局变量frame_index的值

				//计算动画的变换矩阵：matrix1=skinWeight[0]*matrixs[mySkinIndex[0]]+...
            	mat4 matrix1;//每个点只与一个骨骼相关
            	float i0=0.0;
                for(int i=0;i<25;i++){
                   	if((skinIndex[0]-i0)>-0.5&&(skinIndex[0]-i0)<0.5){
                   	    	    matrix1=getMatrix(i);
                   	}
                   	i0=i0+1.0;
                }

				mat4 matrix2 = mat4(//确定位置//最后一列是 0 0 0 1
					vec4( mcol0, 0),
					vec4( mcol1, 0),
					vec4( mcol2, 0),
					vec4( mcol3, 1)
				);

				gl_Position = projectionMatrix * modelViewMatrix*  matrix2  * matrix1 * vec4( position, 1.0 );

		}
		float computeErr_i(int b){//0-1
					float a=int2float(b);
					return
					(
						decode(getNumByTexture(a+0.0),getNumByTexture(a+768.0))
						-
						skeletonData[b]
					)/(skeletonData[b]*2.56);
		}
		float computeErr(int type){
			float a=1.0;
			float aMax=1.0;
			int   bMax=1;
			float errMax=computeErr_i(0);
			/*for(int b=1;b<760;b++){//760
					float err0=computeErr_i(b);
					if(errMax<err0){
						errMax=err0;
						aMax=a;
						bMax=b;
					}
					a+=1.0;
				}
			if(type==0)return errMax;
			else return aMax;*/
			return computeErr_i(0);
		}
		int computeErr_(){
			float a=1.0;
			float aMax=1.0;
			int   bMax=1;
			float errMax=computeErr_i(0);
			for(int b=1;b<760;b++){
					float err0=computeErr_i(b);
					if(errMax<err0){
						errMax=err0;
						aMax=a;
						bMax=b;
					}
					a+=1.0;
				}
			return bMax;
		}
		float getNumByTexture(float n){
			vec3 tttt=texture2D(dataTexture, vec2(
						(0.5+0.0)/1.0,    //宽width
						(0.5+floor(n/3.0))/dataTextureHeight   //高height
				)).xyz;
			float m=modFloor(n,3.0);
			//return m/256.0;
			if(m<0.5)return tttt.x;
			else if(m<1.5)return tttt.y;
			else return tttt.z;
		}
		float decode(float A,float B){//0-1
			A*=256.0;
			B*=256.0;
			float a,b,c,d;
            a=floor(A/128.0);
            b=floor((modFloor(A,128.0))/16.0);
            c=modFloor(A,16.0);
            d=B;

            float c_d=c*256.0+d;
            float num=c_d*pow(10.0,b-5.0);
            if(a==1.0)num*=-1.0;
            return num;
		}
		float getI(int m){//取手臂骨骼数据
			float n=int2float(m);
			float A=getNumByTexture(n),B=getNumByTexture(n+dataTextureHeight*3.0/2.0);
            return decode(A,B);
		}
		void noShader(){
			gl_Position=vec4( 0.0,0.0,0.0,0.0 );
		}
		float modFloor(float a,float b){
			return ( a/b-floor(a/b) )*b;
		}
		void frame_indexSet(){//求帧序号//int frame_index;
					//mod(time*speed,16.0);
					//mod(2,1);
					//int a=2 mod 1;
					//mod(2.0,1.0);
					float t=modFloor(time*speed,16.0);//((time*speed)/16.0-floor((time*speed)/16.0))*16.0;//将time*speed对8取余结果：[0，7)

					if(t>-0.5&&t<=0.5)frame_index=0;
					else if(t>0.5&&t<=1.5)frame_index=1;
					else if(t>1.5&&t<=2.5)frame_index=2;
					else if(t>2.5&&t<=3.5)frame_index=3;
					else if(t>3.5&&t<=4.5)frame_index=4;
					else if(t>4.5&&t<=5.5)frame_index=5;
					else if(t>5.5&&t<=6.5)frame_index=6;
					else if(t>6.5&&t<=7.5)frame_index=7;
					else if(t>7.5&&t<=8.5)frame_index=7;
					else if(t>8.5&&t<=9.5)frame_index=6;
					else if(t>9.5&&t<=10.5)frame_index=5;
					else if(t>10.5&&t<=11.5)frame_index=4;
					else if(t>11.5&&t<=12.5)frame_index=3;
					else if(t>12.5&&t<=13.5)frame_index=2;
					else if(t>13.5&&t<=14.5)frame_index=1;
					else frame_index=0;
		}
		mat4 getMatrixs_i(int i){//求不动位置的骨骼
        	if(i>14)i=i-8;
        	return mat4(//最后一列是：0 0 0 1
				    	    skeletonMatrix[i*12+0] ,skeletonMatrix[i*12+1] ,skeletonMatrix[i*12+2] ,0 ,
				  	      	skeletonMatrix[i*12+3] ,skeletonMatrix[i*12+4] ,skeletonMatrix[i*12+5] ,0 ,
				    	    skeletonMatrix[i*12+6] ,skeletonMatrix[i*12+7] ,skeletonMatrix[i*12+8] ,0 ,
				    	    skeletonMatrix[i*12+9],skeletonMatrix[i*12+10],skeletonMatrix[i*12+11] ,1
			    	    );
        }
        mat4 getMatrixs0_i(int iii){//求手臂骨骼
					int i=iii-7;//iii的取值范围是7-14 -> 0-7
					return mat4(//最后一列是：0 0 0 1
				    	    getI(frame_index*96+i*12+0) ,getI(frame_index*96+i*12+1) ,getI(frame_index*96+i*12+2) ,0,
				  	      	getI(frame_index*96+i*12+3) ,getI(frame_index*96+i*12+4) ,getI(frame_index*96+i*12+5) ,0 ,
				    	    getI(frame_index*96+i*12+6) ,getI(frame_index*96+i*12+7) ,getI(frame_index*96+i*12+8) ,0,
				    	    getI(frame_index*96+i*12+9) ,getI(frame_index*96+i*12+10),getI(frame_index*96+i*12+11),1
			    	    );
					/*return mat4(//最后一列是：0 0 0 1
				    	    getI(frame_index*96+i*12+0) ,getI(frame_index*96+i*12+1) ,getI(frame_index*96+i*12+2) ,0,
				  	      	getI(frame_index*96+i*12+3) ,getI(frame_index*96+i*12+4) ,getI(frame_index*96+i*12+5) ,0 ,
				    	    getI(frame_index*96+i*12+6) ,getI(frame_index*96+i*12+7) ,getI(frame_index*96+i*12+8) ,0,
				    	    getI(frame_index*96+i*12+9) ,getI(frame_index*96+i*12+10),getI(frame_index*96+i*12+11),1
			    	    );
					return mat4(//最后一列是：0 0 0 1
				    	    skeletonData[frame_index*96+i*12+0] ,skeletonData[frame_index*96+i*12+1] ,skeletonData[frame_index*96+i*12+2] ,0,
				  	      	skeletonData[frame_index*96+i*12+3] ,skeletonData[frame_index*96+i*12+4] ,skeletonData[frame_index*96+i*12+5] ,0 ,
				    	    skeletonData[frame_index*96+i*12+6] ,skeletonData[frame_index*96+i*12+7] ,skeletonData[frame_index*96+i*12+8] ,0,
				    	    skeletonData[frame_index*96+i*12+9] ,skeletonData[frame_index*96+i*12+10],skeletonData[frame_index*96+i*12+11],1
			    	    );*/
		}
		mat4 getMatrix(int i){//求骨骼
					if(i>=7&&i<=14) return getMatrixs0_i(i);
					else return getMatrixs_i(i);
		}
		int float2int(float n){
			if(n>0.0){
				int a=0;
				for(float b=0.0;b<=1000.0;b+=1.0){
					if(b>n)break;
					a++;
				}
				return a-1;
			}else{
				return -1;
			}
		}
		float int2float(int n){
			if(n>0){
				float b=0.0;
				for(int a=0;a<=1000;a++){
					if(a>n)break;
					b+=1.0;
				}
				return b-1.0;
			}else{
				return -1.0;
			}
		}
	</script>
	<script id="fragmentShader" type="x-shader/x-fragment">
        precision highp float;

        uniform sampler2D text0;
        uniform sampler2D text1;
        uniform sampler2D text2;
        uniform sampler2D text3;
        uniform sampler2D text4;
        uniform sampler2D text5;
        uniform sampler2D text6;
        uniform sampler2D text7;
        uniform sampler2D text8;
        uniform sampler2D text9;
        uniform sampler2D text10;
        uniform sampler2D text11;
        uniform sampler2D text12;
        uniform sampler2D text13;
        uniform sampler2D text14;
        uniform sampler2D text15;

        varying float type_part;

        varying vec3 varyType;
        varying vec3 varyColor;
		varying vec2 outUV;

		varying float myTest00;
		varying vec3 myTest01;

		void main(){
			gl_FragColor = vec4 (
            					 myTest01.x,
            					 myTest01.y,
            					 myTest01.z,
            					 1.0
            					 );
            					 //return;
			vec4 myTexture;
			float type;

            if(floor(type_part)==0.0)type=varyType[0];//下身
            else if(floor(type_part)==1.0)type=varyType[1];
            else if(floor(type_part)==2.0)type=varyType[2];

               if (type>-0.1&&type<0.1)myTexture =texture2D(text0, outUV);
			else if(type>0.9&&type<1.1)myTexture =texture2D(text1, outUV);
			else if(type>1.9&&type<2.1)myTexture =texture2D(text2, outUV);
			else if(type>2.9&&type<3.1)myTexture =texture2D(text3, outUV);
			else if(type>3.9&&type<4.1)myTexture =texture2D(text4, outUV);
			else if(type>4.9&&type<5.1)myTexture =texture2D(text5, outUV);
			else if(type>5.9&&type<6.1)myTexture =texture2D(text6, outUV);
			else if(type>6.9&&type<7.1)myTexture =texture2D(text7, outUV);
			else if(type>7.9&&type<8.1)myTexture =texture2D(text8, outUV);
			else if(type>8.9&&type<9.1)myTexture =texture2D(text9, outUV);
			else if(type>9.9&&type<10.1)myTexture =texture2D(text10, outUV);
			else if(type>10.9&&type<11.1)myTexture =texture2D(text11, outUV);
			else if(type>11.9&&type<12.1)myTexture =texture2D(text12, outUV);
			else if(type>12.9&&type<13.1)myTexture =texture2D(text13, outUV);
			else if(type>13.9&&type<14.1)myTexture =texture2D(text14, outUV);
			else myTexture =texture2D(text15, outUV);

            if(floor(type_part)==0.0){//下身
            	gl_FragColor = vec4 (
            					 myTexture.r+varyColor[0],
            					 myTexture.g+varyColor[1],
            					 myTexture.b+varyColor[2],
            					 1.0);
            }else if(floor(type_part)==1.0){//上身
            	gl_FragColor = vec4 (
            					 myTexture.r,
            					 myTexture.g,
            					 myTexture.b,
            					 1.0);
            }else if(floor(type_part)==2.0){//头部
            	gl_FragColor = vec4 (
            					 myTexture.r,
            					 myTexture.g,
            					 myTexture.b,
            					 1.0);
            }
		}
</script>
	<script id="vertexShader_" type="x-shader/x-vertex">
		precision highp float;//highp
		uniform mat4 modelViewMatrix;
		uniform mat4 projectionMatrix;

		uniform float skeletonMatrix[204];//骨骼(25-8)*12=204//骨骼矩阵//用于求不动位置的骨骼
		uniform float skeletonData[768];//帧数8*骨骼8*12=768//用于求手臂骨骼//8个手臂骨骼的数据//uniform float[]最大长度4088//变化范围12(0-11)

		uniform float time;//0-10000

		attribute vec3 position;
		attribute vec2 inUV;
        attribute vec4 skinIndex;
        attribute vec4 skinWeight;

        attribute float random;

		attribute float speed;

		attribute vec3 mcol0;
		attribute vec3 mcol1;
		attribute vec3 mcol2;
		attribute vec3 mcol3;

		attribute vec4 type;   //type[3]是0或1，用于表示动画
		attribute vec3 color;

        varying vec2 outUV;
        varying vec3 varyType;
        varying vec3 varyColor;
        varying float type_part;
        varying float myTest00;

		int frame_index;
		mat4 matrixs[25];//所有的骨骼矩阵//matrixsSet()

		void frame_indexSet(){//求帧序号//int frame_index;
					float t=((time*speed)/16.0-floor((time*speed)/16.0))*16.0;//将time*speed对8取余结果：[0，7)

					if(t>-0.5&&t<=0.5)frame_index=0;
					else if(t>0.5&&t<=1.5)frame_index=1;
					else if(t>1.5&&t<=2.5)frame_index=2;
					else if(t>2.5&&t<=3.5)frame_index=3;
					else if(t>3.5&&t<=4.5)frame_index=4;
					else if(t>4.5&&t<=5.5)frame_index=5;
					else if(t>5.5&&t<=6.5)frame_index=6;
					else if(t>6.5&&t<=7.5)frame_index=7;
					else if(t>7.5&&t<=8.5)frame_index=7;
					else if(t>8.5&&t<=9.5)frame_index=6;
					else if(t>9.5&&t<=10.5)frame_index=5;
					else if(t>10.5&&t<=11.5)frame_index=4;
					else if(t>11.5&&t<=12.5)frame_index=3;
					else if(t>12.5&&t<=13.5)frame_index=2;
					else if(t>13.5&&t<=14.5)frame_index=1;
					else frame_index=0;
		}
        mat4 getMatrixs_i(int i){//求不动位置的骨骼
        	if(i>14)i=i-8;
        	return mat4(//最后一列是：0 0 0 1
				    	    skeletonMatrix[i*12+0] ,skeletonMatrix[i*12+1] ,skeletonMatrix[i*12+2] ,0 ,
				  	      	skeletonMatrix[i*12+3] ,skeletonMatrix[i*12+4] ,skeletonMatrix[i*12+5] ,0 ,
				    	    skeletonMatrix[i*12+6] ,skeletonMatrix[i*12+7] ,skeletonMatrix[i*12+8] ,0 ,
				    	    skeletonMatrix[i*12+9],skeletonMatrix[i*12+10],skeletonMatrix[i*12+11] ,1
			    	    );
        }
		mat4 getMatrixs0_i(int iii){//求手臂骨骼
					int i=iii-7;//iii的取值范围是7-14 -> 0-7
					return mat4(//最后一列是：0 0 0 1
				    	    skeletonData[frame_index*96+i*12+0] ,skeletonData[frame_index*96+i*12+1] ,skeletonData[frame_index*96+i*12+2] ,0,
				  	      	skeletonData[frame_index*96+i*12+3] ,skeletonData[frame_index*96+i*12+4] ,skeletonData[frame_index*96+i*12+5] ,0 ,
				    	    skeletonData[frame_index*96+i*12+6] ,skeletonData[frame_index*96+i*12+7] ,skeletonData[frame_index*96+i*12+8] ,0,
				    	    skeletonData[frame_index*96+i*12+9] ,skeletonData[frame_index*96+i*12+10],skeletonData[frame_index*96+i*12+11],1
			    	    );
		}


		void matrixsSet(){
						frame_indexSet();//设置全局变量frame_index的值

						for(int i=0;i<7;i++)matrixs[i]=getMatrixs_i(i);
			    	    for(int i=7;i<15;i++)matrixs[i]=getMatrixs0_i(i);//胳膊
						for(int i=15;i<25;i++)matrixs[i]=getMatrixs_i(i);
		}
		void main(){
			    vec3 vPosition = position;

				outUV = inUV;
				varyType=vec3(type[0],type[1],type[2]);
				varyColor=vec3(color[0],color[1],color[2]);
				myTest00=type[3];

				if(vPosition.y<0.15)type_part=0.0;//下身
				else if(vPosition.y<0.59) type_part=1.0;//上身
				else type_part=2.0;//头部

				matrixsSet();//求所有的骨骼矩阵

				int mySkinIndex[4];//求skinIndex的近似整数，结果存入mySkinIndex
            	for(int j=0;j<4;j++){
                	float i0=0.0;
                	for(int i=0;i<25;i++){
                   	if((skinIndex[j]-i0)>-0.5&&(skinIndex[j]-i0)<0.5){
                        	    mySkinIndex[j]=i;
                   	}
                   	i0=i0+1.0;
                	}
            	}
            	//计算动画的变换矩阵：matrix1=skinWeight[0]*matrixs[mySkinIndex[0]]+...
            	mat4 matrix1=mat4(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);
            	mat4 matrix_temp;
            	for(int i=0;i<25;i++)
	                if(i==mySkinIndex[0]){
    	                matrix_temp=matrixs[i];
        	            matrix1=matrix1+skinWeight[0]*matrix_temp;
            	    }else if(i==mySkinIndex[1]){
                	    matrix_temp=matrixs[i];
                    	matrix1=matrix1+skinWeight[1]*matrix_temp;
	                }else if(i==mySkinIndex[2]){
    	                matrix_temp=matrixs[i];
        	            matrix1=matrix1+skinWeight[2]*matrix_temp;
            	    }else if(i==mySkinIndex[3]){
                	    matrix_temp=matrixs[i];
                    	matrix1=matrix1+skinWeight[3]*matrix_temp;
         	        }

				mat4 matrix2 = mat4(//确定位置//最后一列是 0 0 0 1
					vec4( mcol0, 0),
					vec4( mcol1, 0),
					vec4( mcol2, 0),
					vec4( mcol3, 1)
				);

				gl_Position = projectionMatrix * modelViewMatrix*  matrix2  * matrix1 * vec4( position, 1.0 );

		}
	</script>
	<script id="fragmentShader_" type="x-shader/x-fragment">
        precision highp float;
        uniform sampler2D text0;
        uniform sampler2D text1;
        uniform sampler2D text2;
        uniform sampler2D text3;
        uniform sampler2D text4;
        uniform sampler2D text5;
        uniform sampler2D text6;
        uniform sampler2D text7;
        uniform sampler2D text8;
        uniform sampler2D text9;
        uniform sampler2D text10;
        uniform sampler2D text11;
        uniform sampler2D text12;
        uniform sampler2D text13;
        uniform sampler2D text14;
        uniform sampler2D text15;

        varying float type_part;

        varying vec3 varyType;
        varying vec3 varyColor;
		varying vec2 outUV;

		varying float myTest00;

		void main(){
			vec4 myTexture;
			float type;

            if(floor(type_part)==0.0)type=varyType[0];//下身
            else if(floor(type_part)==1.0)type=varyType[1];
            else if(floor(type_part)==2.0)type=varyType[2];

               if (type>-0.1&&type<0.1)myTexture =texture2D(text0, outUV);
			else if(type>0.9&&type<1.1)myTexture =texture2D(text1, outUV);
			else if(type>1.9&&type<2.1)myTexture =texture2D(text2, outUV);
			else if(type>2.9&&type<3.1)myTexture =texture2D(text3, outUV);
			else if(type>3.9&&type<4.1)myTexture =texture2D(text4, outUV);
			else if(type>4.9&&type<5.1)myTexture =texture2D(text5, outUV);
			else if(type>5.9&&type<6.1)myTexture =texture2D(text6, outUV);
			else if(type>6.9&&type<7.1)myTexture =texture2D(text7, outUV);
			else if(type>7.9&&type<8.1)myTexture =texture2D(text8, outUV);
			else if(type>8.9&&type<9.1)myTexture =texture2D(text9, outUV);
			else if(type>9.9&&type<10.1)myTexture =texture2D(text10, outUV);
			else if(type>10.9&&type<11.1)myTexture =texture2D(text11, outUV);
			else if(type>11.9&&type<12.1)myTexture =texture2D(text12, outUV);
			else if(type>12.9&&type<13.1)myTexture =texture2D(text13, outUV);
			else if(type>13.9&&type<14.1)myTexture =texture2D(text14, outUV);
			else myTexture =texture2D(text15, outUV);

            float mytest0=varyType[1]*0.01;
            if(floor(type_part)==0.0){//下身
            	gl_FragColor = vec4 (
            					 myTexture.r+varyColor[0],
            					 myTexture.g+varyColor[1],
            					 myTexture.b+varyColor[2],
            					 1.0);
            }else if(floor(type_part)==1.0){//上身
            	gl_FragColor = vec4 (
            					 myTexture.r,
            					 myTexture.g,
            					 myTexture.b,
            					 1.0);
            }else if(floor(type_part)==2.0){//头部
            	gl_FragColor = vec4 (
            					 myTexture.r,
            					 myTexture.g,
            					 myTexture.b,
            					 1.0);
            }
		}
</script>
	<!--无骨骼动画的着色器-->
	<script id="vertexShader0" type="x-shader/x-vertex">//
		precision highp float;
		uniform mat4 modelViewMatrix;
		uniform mat4 projectionMatrix;


		attribute vec3 position;
		attribute vec2 inUV;

        attribute float random;

		attribute vec3 mcol0;
		attribute vec3 mcol1;
		attribute vec3 mcol2;
		attribute vec3 mcol3;

		attribute vec4 type;   //type[3]是0或1，用于表示动画
		attribute vec3 color;

        varying vec2 outUV;
        varying vec3 varyType;
        varying vec3 varyColor;
        varying float type_part;
        varying float myTest00;

		void main(){
			vec3 vPosition = position;
			//if(random<0.8)//显示百分之80三角面
			//if(vPosition.y<1.8)//全身显示
			//if(vPosition.y>0.61&&vPosition.x>0.0)//只显示脸

			if(true)//全身显示
			//if(vPosition.x>-0.09)//前半部分
			//if((vPosition.x>-0.01&&vPosition.y>0.1)||vPosition.y>0.65)//只显示前半部分的上半身和头
			//if(vPosition.x>-0.01&&vPosition.y>0.1)//只显示前半部分的上半身
			{
				outUV = inUV;
				varyType=vec3(type[0],type[1],type[2]);
				varyColor=vec3(color[0],color[1],color[2]);
				myTest00=type[3];

				if(position.z<-0.95)type_part=2.0;//头部
				else if(position.z<-0.60) type_part=1.0;//上身
				else type_part=0.0;//下身

				//if(position.z<-1.0)type_part=0.0;
				//else type_part=1.0;

				mat4 matrix2 = mat4(//确定位置//最后一列是 0 0 0 1
					vec4( mcol0, 0),
					vec4( mcol1, 0),
					vec4( mcol2, 0),
					vec4( mcol3, 1)
				);

				gl_Position = projectionMatrix * modelViewMatrix*  matrix2  *  vec4( position, 1.0 );
				//gl_Position = projectionMatrix * modelViewMatrix*  matrix2  * matrix1 * vec4( position, 1.0 );
			}
		}
	</script>
	<script id="fragmentShader0" type="x-shader/x-fragment">
        precision highp float;
        uniform sampler2D text0;
        uniform sampler2D text1;
        uniform sampler2D text2;
        uniform sampler2D text3;
        uniform sampler2D text4;
        uniform sampler2D text5;
        uniform sampler2D text6;
        uniform sampler2D text7;
        uniform sampler2D text8;
        uniform sampler2D text9;
        uniform sampler2D text10;
        uniform sampler2D text11;
        uniform sampler2D text12;
        uniform sampler2D text13;
        uniform sampler2D text14;
        uniform sampler2D text15;

        varying float type_part;

        varying vec3 varyType;
        varying vec3 varyColor;
		varying vec2 outUV;

		varying float myTest00;

		void main(){
			vec4 myTexture;
			float type;

            if(floor(type_part)==0.0)type=varyType[0];//下身
            else if(floor(type_part)==1.0)type=varyType[1];
            else if(floor(type_part)==2.0)type=varyType[2];

               if (type>-0.1&&type<0.1)myTexture =texture2D(text0, outUV);
			else if(type>0.9&&type<1.1)myTexture =texture2D(text1, outUV);
			else if(type>1.9&&type<2.1)myTexture =texture2D(text2, outUV);
			else if(type>2.9&&type<3.1)myTexture =texture2D(text3, outUV);
			else if(type>3.9&&type<4.1)myTexture =texture2D(text4, outUV);
			else if(type>4.9&&type<5.1)myTexture =texture2D(text5, outUV);
			else if(type>5.9&&type<6.1)myTexture =texture2D(text6, outUV);
			else if(type>6.9&&type<7.1)myTexture =texture2D(text7, outUV);
			else if(type>7.9&&type<8.1)myTexture =texture2D(text8, outUV);
			else if(type>8.9&&type<9.1)myTexture =texture2D(text9, outUV);
			else if(type>9.9&&type<10.1)myTexture =texture2D(text10, outUV);
			else if(type>10.9&&type<11.1)myTexture =texture2D(text11, outUV);
			else if(type>11.9&&type<12.1)myTexture =texture2D(text12, outUV);
			else if(type>12.9&&type<13.1)myTexture =texture2D(text13, outUV);
			else if(type>13.9&&type<14.1)myTexture =texture2D(text14, outUV);
			else myTexture =texture2D(text15, outUV);

            float mytest0=varyType[1]*0.01;

            /**/if(floor(type_part)==0.0){//下身
            	gl_FragColor = vec4 (
            					 myTexture.r+varyColor[0],
            					 myTexture.g+varyColor[1],
            					 myTexture.b+varyColor[2],
            					 1.0);
            }else if(floor(type_part)==1.0){//上身
            	gl_FragColor = vec4 (
            					 myTexture.r,
            					 myTexture.g,
            					 myTexture.b,
            					 1.0);
            }else if(floor(type_part)==2.0){//头部
            	gl_FragColor = vec4 (
            					 myTexture.r,
            					 myTexture.g,
            					 myTexture.b,
            					 1.0);
            }
            //gl_FragColor =vec4 (0.0,type_part,myTest00,1.0);//myTest00值为0

            /*if(floor(type_part)==2.0)
            			gl_FragColor = vec4 (
            					 myTexture.r+0.5,
            					 myTexture.g,
            					 myTexture.b,
            					 1.0);*/
		}
</script>

		<script src="lib/threeJS/three.js"></script>
		<script src="lib/threeJS/OrbitControls.js"></script>
		<script src="lib/threeJS/GLTFLoader.js"></script>

		<script src="lib/pmLib/PMAnimLoader.js"></script>
		<script src="lib/pmLib/MyPMLoader.js"></script>

		<script src="js/sceneSet/RoomManager.js"></script>
		<script src="js/sceneSet/SeatManager.js"></script>
		<script src="js/sceneSet/AvatarManager.js"></script>

		<script src="js/playerControl/PlayerControl.js"></script>
		<script src="js/playerControl/PreviewManager.js"></script>

		<script src="js/InstancedGroup.js"></script>
		<script src="js/ParamMeasure.js"></script>
		<script src="js/Main.js"></script>

		<script src="test/testLaunch.js"></script>
	</body>
</html>
